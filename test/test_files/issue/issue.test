-GROUP IssueTest
-DATASET CSV empty

--

-CASE 2158
-STATEMENT CREATE NODE TABLE N1(name STRING, PRIMARY KEY(name));
---- ok
-STATEMENT CREATE NODE TABLE N2(name STRING, PRIMARY KEY(name));
---- ok
-STATEMENT CREATE REL TABLE Rel1(FROM N1 TO N2);
---- ok
-STATEMENT CREATE REL TABLE Rel2(FROM N1 TO N2);
---- ok
-STATEMENT CREATE (n1:N1 {name: "n1a"}), (n2:N2 {name: "n2a"}), (n1)-[:Rel1]->(n2);
---- ok
-STATEMENT MATCH p = (n1:N1)-[:Rel1]->() return length(p);
---- 1
1

-CASE 2167
-STATEMENT CREATE NODE TABLE Test(id SERIAL, content STRING, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE (t:Test {content: "mycontent"}) RETURN t;
---- 1
{_ID: 0:0, _LABEL: Test, id: 0, content: mycontent}
-STATEMENT MATCH (t:Test) RETURN t;
---- 1
{_ID: 0:0, _LABEL: Test, id: 0, content: mycontent}

-CASE Kind-Of-Fruit
-STATEMENT CREATE NODE TABLE T(name STRING, PRIMARY KEY(name));
---- ok
-STATEMENT CREATE NODE TABLE Fruit(name STRING, PRIMARY KEY(name));
---- ok
-STATEMENT CREATE REL TABLE LIKES(FROM T TO Fruit);
---- ok
-STATEMENT CREATE REL TABLE KIND_OF(FROM T TO T);
---- ok
-STATEMENT CREATE
        (t1:T {name: "T1"}),
        (t2:T {name: "T2"}),
        (t3:T {name: "T3"}),
        (f1:Fruit {name: "Banana"}),
        (f2:Fruit {name: "Orange"}),
        (f3:Fruit {name: "Apple"}),
        (t1)-[:LIKES]->(f1),
        (t2)-[:LIKES]->(f2),
        (t3)-[:LIKES]->(f3),
        (t1)-[:KIND_OF]->(t2),
        (t2)-[:KIND_OF]->(t3);
---- ok
-STATEMENT MATCH (t1:T)-[:KIND_OF*]->(t2:T), (t1)-[:LIKES]->(f1:Fruit), (t2)-[:LIKES]->(f2:Fruit)
            WHERE f1.name = "Apple" and f2.name = "Banana" OR f1.name = "Banana" and f2.name = "Apple" return t1 as t
---- 1
{_ID: 0:0, _LABEL: T, name: T1}
-STATEMENT MATCH (t:T)-[:LIKES]->(:Fruit {name: "Apple"}), (t)-[:LIKES]->(:Fruit {name: "Banana"}) return t;
---- 0
-STATEMENT MATCH (t1:T)-[:KIND_OF*]->(t2:T), (t1)-[:LIKES]->(f1:Fruit), (t2)-[:LIKES]->(f2:Fruit)
            WHERE f1.name = "Apple" and f2.name = "Banana" OR f1.name = "Banana" and f2.name = "Apple" return t1 as t
           UNION
           MATCH (t:T)-[:LIKES]->(:Fruit {name: "Apple"}), (t)-[:LIKES]->(:Fruit {name: "Banana"}) return t;
---- 1
{_ID: 0:0, _LABEL: T, name: T1}

-CASE 2184
-STATEMENT CREATE NODE TABLE T(name STRING, PRIMARY KEY(name));
---- ok
-STATEMENT CREATE NODE TABLE T2(name STRING, myprops MAP(STRING,STRING), PRIMARY KEY(name));
---- ok
-STATEMENT CREATE REL TABLE KIND_OF3(FROM T TO T, myprops MAP(STRING,STRING));
---- ok
-STATEMENT CREATE REL TABLE KIND_OF4(FROM T TO T, myprops SERIAL);
---- error
Binder exception: SERIAL properties are not supported in rel tables.
-STATEMENT CREATE (:T {name: "Foo"});
---- ok
-STATEMENT CREATE (:T {name: "Bar"});
---- ok
-STATEMENT MATCH (t1:T), (t2:T) where t1.name = 'Foo' AND t2.name = "Bar" CREATE (t1)-[:KIND_OF3 {myprops: map(['1', '2'], ['a', 'b'])}]->(t2);
---- ok

-CASE 2293
-STATEMENT CREATE NODE TABLE T(id INT64, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE REL TABLE KNOWS(FROM T TO T);
---- ok
-STATEMENT CREATE (t1:T {id: 0}), (t2:T {id: 1});
---- ok
-STATEMENT MATCH (t1:T)-[e]-(t2:T) RETURN COUNT(*);
---- 1
0
-STATEMENT MATCH (t1:T {id: 0}), (t2: T {id: 1}) OPTIONAL MATCH (t1)-[e:KNOWS]->() DELETE e;
---- ok
-STATEMENT MATCH (t1:T)-[e]-(t2:T) RETURN COUNT(*);
---- 1
0

-CASE 2376
-STATEMENT CREATE NODE TABLE thing(name STRING, PRIMARY KEY (name));
---- ok
-STATEMENT MATCH (n) DELETE n
---- ok
-STATEMENT MERGE (n:thing {name: 'original'})
---- ok
-STATEMENT MATCH (n:thing) RETURN n
---- 1
{_ID: 0:0, _LABEL: thing, name: original}
-STATEMENT MATCH (n:thing {name: 'original'}) SET n.name = 'rename 1x' RETURN n
---- 1
{_ID: 0:0, _LABEL: thing, name: rename 1x}
-STATEMENT MATCH (n:thing {name: 'rename 1x'}) SET n.name = 'rename 2x' RETURN n
---- 1
{_ID: 0:0, _LABEL: thing, name: rename 2x}
-STATEMENT CREATE (n:thing {name: 'original'})
---- ok
-STATEMENT CREATE (n:thing {name: 'rename 1x'})
---- ok
-STATEMENT CREATE (n:thing {name: 'rename 2x'})
---- error
Runtime exception: Found duplicated primary key value rename 2x, which violates the uniqueness constraint of the primary key column.
-STATEMENT MATCH (n:thing) WHERE n.name='rename 1x' DELETE n
---- ok
-STATEMENT MATCH (n:thing) RETURN n
---- 2
{_ID: 0:1, _LABEL: thing, name: original}
{_ID: 0:0, _LABEL: thing, name: rename 2x}


-CASE 2294
-STATEMENT CREATE NODE TABLE T(id INT64, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE REL TABLE KNOWS(FROM T TO T);
---- ok
-STATEMENT OPTIONAL MATCH (a)-[b:KNOWS]->(c) return a,b,c;
---- 1
||


-CASE 2303
-STATEMENT CREATE NODE TABLE T (id STRING, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE REL TABLE AFTER (FROM T TO T, id STRING);
---- ok
-STATEMENT CREATE (t1:T {id: "t1"})-[e1:AFTER {id: "e1"}]->(t2:T {id: "t2"})-[e2:AFTER {id: "e2"}]->(t3:T {id: "t3"}),
        (t4:T {id: "t4"})-[e3:AFTER {id: "e3"}]->(t5:T {id: "t5"})-[e4:AFTER {id: "e4"}]->(t6:T {id: "t6"})-[e5:AFTER {id: "e5"}]->(t7:T {id: "t7"})
---- ok
-STATEMENT MATCH p = (a:T {id:"t4"})-[e*]->(b:T {id:"t7"}) RETURN COUNT(*);
---- 1
1
-STATEMENT MATCH (s:T {id: "t2"}), (a:T {id: "t6"}),
           (t1:T)-[e1:AFTER]->(s),
           (s)-[e2:AFTER]->(t3:T),
           (t5:T)-[e4:AFTER]->(a)
           DELETE e1,e2,e4
           CREATE (s)-[e7:AFTER]->(a)
           CREATE (t1)-[e8:AFTER]->(t3)
           CREATE (t5)-[e9:AFTER]->(s);
---- ok
-STATEMENT MATCH (a)-[e]->(b) RETURN COUNT(*);
---- 1
5
-STATEMENT MATCH p = (a:T {id:"t4"})-[e*]->(b:T {id:"t7"}) RETURN COUNT(*);
---- 1
1

-CASE 2558
-STATEMENT CREATE NODE TABLE T(id STRING, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE REL TABLE R (FROM T TO T);
---- ok
-STATEMENT OPTIONAL MATCH (b {id: "non existent id"}) RETURN b is NULL;
---- 1
True
-STATEMENT OPTIONAL MATCH (b{id: "non existent id"}) RETURN CASE WHEN b is NULL THEN "foo" ELSE "bar" END;
---- 1
foo
-STATEMENT OPTIONAL MATCH (b {id: "non existent id"})-[r]->(c) RETURN b is NULL, r is NULL, c is NULL;
---- 1
True|True|True

-CASE 2578
-STATEMENT CREATE NODE TABLE T(id STRING, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE REL TABLE CHILD_OF(FROM T TO T);
---- ok
-STATEMENT CREATE (t1:T {id: "t1"}),
 (t11:T {id: "t11"}),
 (t12:T {id: "t12"}),
 (t13:T {id: "t13"}),
 (t111:T {id: "t111"}),
 (t112:T {id: "t112"}),
 (t1111:T {id: "t1111"}),
 (t2:T {id: "t2"}),
 (t21:T {id: "t21"}),
 (t22:T {id: "t22"}),
 (t3:T {id: "t3"}),
 (t1111)-[:CHILD_OF]->(t111),
 (t111)-[:CHILD_OF]->(t11),
 (t112)-[:CHILD_OF]->(t11),
 (t11)-[:CHILD_OF]->(t1),
 (t12)-[:CHILD_OF]->(t1),
 (t13)-[:CHILD_OF]->(t1),
 (t21)-[:CHILD_OF]->(t2),
 (t22)-[:CHILD_OF]->(t2);
---- ok
-STATEMENT WITH "t1" as parentid
           MATCH p = (t1:T)<-[e:CHILD_OF*0..1]-(t0:T)
           WHERE CASE
             WHEN parentid IS NULL THEN NOT EXISTS {MATCH (t1)-[:CHILD_OF]->(:T)}
             ELSE EXISTS {MATCH (t1)-[:CHILD_OF]->(:T {id: parentid})}
           END
           AND (NOT EXISTS {MATCH (:T)-[:CHILD_OF]->(t0)} OR length(e) = 1)
           RETURN properties(nodes(p),'id');
---- 4
[t11,t111]
[t11,t112]
[t12]
[t13]
-STATEMENT WITH NULL as parentid
           MATCH p = (t1:T)<-[e:CHILD_OF*0..1]-(t0:T)
           WHERE CASE
             WHEN parentid IS NULL THEN NOT EXISTS {MATCH (t1)-[:CHILD_OF]->(:T)}
             ELSE EXISTS {MATCH (t1)-[:CHILD_OF]->(:T {id: parentid})}
           END
           AND (NOT EXISTS {MATCH (:T)-[:CHILD_OF]->(t0)} OR length(e) = 1)
           RETURN properties(nodes(p),'id');
---- 6
[t1,t11]
[t1,t12]
[t1,t13]
[t2,t21]
[t2,t22]
[t3]


-CASE 2587
-STATEMENT CREATE NODE TABLE T (id STRING, descr STRING, PRIMARY KEY (id));
---- ok
-STATEMENT CREATE (:T {id: "foo"});
---- ok
-STATEMENT CREATE (:T {id: "123456789012"});
---- ok
-STATEMENT CREATE (:T {id: "bar", descr: "fe38f9dc-f761-4184-8b8b-ec9a1b5ffb83"});
---- ok
-STATEMENT CREATE (:T {id: "ge38f9dc-f751-4174-8b8b-ec9a1b6gab83"});
---- ok
-STATEMENT CREATE (:T {id: "1234567890123"});
---- ok
-STATEMENT MATCH (t:T) RETURN t.*;
---- 5
foo|
123456789012|
bar|fe38f9dc-f761-4184-8b8b-ec9a1b5ffb83
ge38f9dc-f751-4174-8b8b-ec9a1b6gab83|
1234567890123|

-CASE 2588
-STATEMENT CREATE NODE TABLE T (id STRING, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE (:T {id: "t1"}),(:T {id: "t2"});
---- ok
-STATEMENT CALL SHOW_TABLES() WHERE true RETURN *;
---- 1
T|NODE|
-STATEMENT CALL SHOW_TABLES() WHERE false RETURN *;
---- 0

-STATEMENT MATCH (t:T) WHERE false RETURN t.*;
---- 0

-STATEMENT MATCH (t:T) WHERE true RETURN t.*;
---- 2
t1
t2
-STATEMENT MATCH (t:T) WHERE NULL RETURN t.*;
---- 0

-STATEMENT MATCH (t:T) WHERE 2 > 1 + 1 RETURN t.*;
---- 0

-STATEMENT MATCH (t:T) WHERE "aa" STARTS WITH "a" RETURN t.*;
---- 2
t1
t2
-STATEMENT MATCH (t:T) WHERE 1 > null RETURN t.*;
---- 0

-STATEMENT MATCH (t:T) WHERE NULL WITH t MATCH (t2:T) RETURN t.*;
---- 0

-STATEMENT MATCH (t:T) WITH t OPTIONAL MATCH (t2:T) WHERE NULL RETURN t.*;
---- 2
t1
t2

-CASE 2589
-STATEMENT CREATE NODE TABLE T (id STRING,PRIMARY KEY(id));
---- ok
-STATEMENT CREATE REL TABLE E (FROM T TO T);
---- ok
-STATEMENT CREATE (t1:T{id:"t1"})-[:E]->(t2:T{id:"t2"});
---- ok
-STATEMENT WITH "node_after" as selected
        MATCH (t1:T{id: "t1"})-[:E]->(t2:T{id: "t2"})
        WITH
        CASE WHEN selected = "node_after" THEN t2
            ELSE t1
        END as ret
        RETURN ret;
---- 1
{_ID: 0:1, _LABEL: T, id: t2}
-STATEMENT WITH "node_after" as selected
        MATCH (t1:T{id: "t1"})-[:E]->(t2:T{id: "t2"})
        WITH
        CASE WHEN selected <> "node_after" THEN t2
            ELSE t1
        END as ret
        RETURN ret;
---- 1
{_ID: 0:0, _LABEL: T, id: t1}

-CASE 2643
-STATEMENT create node table person (x SERIAL, y STRUCT(a INT64, b INT64), PRIMARY KEY(x));
---- ok
-STATEMENT CREATE (:person {y: {a: 1, b: 2}}), (:person {y: {a: 3, b: 4}});
---- ok
-STATEMENT MATCH (a:person) RETURN a.*;
---- 2
0|{a: 1, b: 2}
1|{a: 3, b: 4}
-STATEMENT create node table organisation (x INT64, y STRUCT(a INT64, b INT64), PRIMARY KEY(x));
---- ok
-STATEMENT CREATE (:organisation {x: 10, y: {a: 1, b: 2}}), (:organisation {x: 11, y: {a: 3, b: 4}});
---- ok
-STATEMENT MATCH (a:organisation) RETURN a.*;
---- 2
10|{a: 1, b: 2}
11|{a: 3, b: 4}

-CASE 2675
-STATEMENT CREATE NODE TABLE V1 (id STRING, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE NODE TABLE V2 (id STRING, PRIMARY KEY (id));
---- ok
-STATEMENT CREATE NODE TABLE V3 (id STRING, PRIMARY KEY (id));
---- ok
-STATEMENT CREATE REL TABLE GROUP MYREL(FROM V3 TO V2, FROM V2 TO V1);
---- ok
-STATEMENT CREATE REL TABLE E(FROM V1 TO V2);
---- ok
-STATEMENT CREATE (v21: V2 {id: "v21"})-[:E]->(v11:V1 {id: "v11"});
---- error
Binder exception: Query node v21 violates schema. Expected labels are V1.
-STATEMENT CREATE (v22:V2 {id: "v22"})-[:E]->(v23: V2 {id: "v23"});
---- error
Binder exception: Query node v22 violates schema. Expected labels are V1.
-STATEMENT CREATE (:V3 {id: "v3"})-[:MYREL]->(:V2 {id: "v2"})
---- ok
-STATEMENT MATCH (a:V3)-[:MYREL]->(b:V2) RETURN a.*, b.*;
---- 1
v3|v2

-CASE 2701
-STATEMENT CREATE NODE TABLE T (id INT64, PRIMARY KEY(id));
---- ok
-STATEMENT CREATE REL TABLE R (FROM T TO T);
---- ok
-STATEMENT CREATE ({id: 1})-[:R]->({id:2});
---- ok
-STATEMENT MATCH (a {id: 1}) CREATE (a)-[:R]->(a);
---- ok
-STATEMENT MATCH (n1), (n2)<-[]-(n2), (n1)<-[]-(n2) RETURN n1.id, n2.id
---- 2
1|1
2|1
