-DATASET CSV empty

--

-CASE Basic
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5),
            (u4)-[:Edge {weight: 2}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='weight') YIELD src, dst, rel, forest_id MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight, forest_id ORDER BY forest_id;
---- 9
0|1|5|0
0|2|6|0
2|3|3|0
3|4|3|0
4|9|2|0
5|7|10|0
6|7|3|0
7|8|10|0
8|9|3|0


-CASE AnotherBasicTest
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MSF('Graph', weight_property:='weight') YIELD src, dst, rel, forest_id MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight, forest_id ORDER BY forest_id;
---- 9
0|1|5|0
0|2|6|0
2|3|3|0
2|5|15|0
3|4|3|0
5|7|10|0
6|7|3|0
7|8|10|0
8|9|3|0

-CASE DisconnectedComponents
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='weight') YIELD src, dst, rel, forest_id MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight, forest_id ORDER BY forest_id;
---- 8
0|1|5|0
0|2|6|0
2|3|3|0
3|4|3|0
5|7|10|5
6|7|3|5
7|8|10|5
8|9|3|5

-CASE NoEdges
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9});
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='weight') YIELD src, dst, rel, forest_id MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight, forest_id ORDER BY forest_id;
---- 0

-CASE MultiEdges
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u0)-[:Edge {weight: 8}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 20}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u6)-[:Edge {weight: 8}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5),
            (u2)-[:Edge {weight: 20}]->(u5),
            (u4)-[:Edge {weight: 2}]->(u9),
            (u4)-[:Edge {weight: 4}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='weight') YIELD src, dst, rel, forest_id MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight, forest_id ORDER BY forest_id;
---- 9
0|1|5|0
0|2|6|0
2|3|3|0
3|4|3|0
4|9|2|0
5|7|10|0
6|7|3|0
7|8|10|0
8|9|3|0

-CASE SelfAndMultiEdges
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 5}]->(u0),
            (u0)-[:Edge {weight: 6}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u0)-[:Edge {weight: 8}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u1)-[:Edge {weight: 5}]->(u1),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 20}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u5)-[:Edge {weight: 60}]->(u5),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u6)-[:Edge {weight: 8}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5),
            (u2)-[:Edge {weight: 20}]->(u5),
            (u2)-[:Edge {weight: 0}]->(u2),
            (u4)-[:Edge {weight: 2}]->(u9),
            (u4)-[:Edge {weight: 4}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='weight') YIELD src, dst, rel, forest_id MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight, forest_id ORDER BY forest_id;
---- 9
0|1|5|0
0|2|6|0
2|3|3|0
3|4|3|0
4|9|2|0
5|7|10|0
6|7|3|0
7|8|10|0
8|9|3|0

-CASE MinVSMaxVSUnweightedForest
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5),
            (u4)-[:Edge {weight: 2}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='weight', max_forest:=false) YIELD src, dst, rel MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight;
---- 9
0|1|5
0|2|6
2|3|3
3|4|3
4|9|2
5|7|10
6|7|3
7|8|10
8|9|3
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='weight', max_forest:=true) YIELD src, dst, rel MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight;
---- 9
0|2|6
1|2|8
2|3|3
2|5|15
3|4|3
5|6|10
5|7|10
7|8|10
8|9|3
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph') YIELD src, dst, rel MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight;
---- 9
0|2|6
1|2|8
2|3|3
2|5|15
3|4|3
4|9|2
5|6|10
5|7|10
8|9|3


-CASE InvalidWeightProperty
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight STRING);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='weight') YIELD src, dst, rel, forest_id MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight, forest_id ORDER BY forest_id;
---- error
Binder exception: Provided weight property is not numerical: weight

-CASE PropertyDoesNotExist
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight STRING);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL MINIMUM_SPANNING_FOREST('Graph', weight_property:='height') YIELD src, dst, rel, forest_id MATCH (n) WHERE ID(n) = dst MATCH ()-[r]->() WHERE ID(r) = rel RETURN src.id AS src, n.id AS dst, r.weight as weight, forest_id ORDER BY forest_id;
---- error
Binder exception: Cannot find property: height
