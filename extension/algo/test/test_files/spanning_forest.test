-DATASET CSV empty

--

-CASE Basic
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5),
            (u4)-[:Edge {weight: 2}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
6|0|2|0
8|1|2|0
3|2|3|0
15|2|5|0
3|3|4|0
2|4|9|0
10|5|6|0
10|5|7|0
3|8|9|0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='min')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
5|0|1|0
6|0|2|0
3|2|3|0
3|3|4|0
2|4|9|0
10|5|7|0
3|6|7|0
10|7|8|0
3|8|9|0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='max')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
6|0|2|2
8|1|2|2
3|2|3|2
15|2|5|2
3|3|4|2
10|5|6|2
10|5|7|2
10|7|8|2
3|8|9|2


-CASE Alias
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SF('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
5|0|1|0
6|0|2|0
3|2|3|0
15|2|5|0
3|3|4|0
10|5|7|0
3|6|7|0
10|7|8|0
3|8|9|0


-CASE DisconnectedComponents
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 8
6|0|2|0
8|1|2|0
3|2|3|0
3|3|4|0
10|5|7|5
3|6|7|5
10|7|8|5
3|8|9|5

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 8
5|0|1|0
6|0|2|0
3|2|3|0
3|3|4|0
10|5|7|5
3|6|7|5
10|7|8|5
3|8|9|5

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='max')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 8
6|0|2|2
8|1|2|2
3|2|3|2
3|3|4|2
10|5|6|8
10|5|7|8
10|7|8|8
3|8|9|8


-CASE NoEdges
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9});
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='min')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='max')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 0


-CASE MultiEdges
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u0)-[:Edge {weight: 8}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 20}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u6)-[:Edge {weight: 8}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5),
            (u2)-[:Edge {weight: 20}]->(u5),
            (u4)-[:Edge {weight: 2}]->(u9),
            (u4)-[:Edge {weight: 4}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
8|0|2|0
8|1|2|0
3|2|3|0
20|2|5|0
3|3|4|0
4|4|9|0
20|5|6|0
10|5|7|0
3|8|9|0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='min')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
5|0|1|0
6|0|2|0
3|2|3|0
3|3|4|0
2|4|9|0
10|5|7|0
3|6|7|0
10|7|8|0
3|8|9|0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='max')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
8|0|2|3
8|1|2|3
20|2|5|3
3|3|4|3
4|4|9|3
20|5|6|3
10|5|7|3
10|7|8|3
3|8|9|3


-CASE SelfAndMultiEdges
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 5}]->(u1),
            (u0)-[:Edge {weight: 5}]->(u0),
            (u0)-[:Edge {weight: 6}]->(u1),
            (u0)-[:Edge {weight: 6}]->(u2),
            (u0)-[:Edge {weight: 8}]->(u2),
            (u1)-[:Edge {weight: 8}]->(u2),
            (u1)-[:Edge {weight: 5}]->(u1),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 3}]->(u4),
            (u5)-[:Edge {weight: 10}]->(u6),
            (u5)-[:Edge {weight: 20}]->(u6),
            (u5)-[:Edge {weight: 10}]->(u7),
            (u5)-[:Edge {weight: 60}]->(u5),
            (u6)-[:Edge {weight: 3}]->(u7),
            (u6)-[:Edge {weight: 8}]->(u7),
            (u7)-[:Edge {weight: 10}]->(u8),
            (u8)-[:Edge {weight: 3}]->(u9),
            (u2)-[:Edge {weight: 15}]->(u5),
            (u2)-[:Edge {weight: 20}]->(u5),
            (u2)-[:Edge {weight: 0}]->(u2),
            (u4)-[:Edge {weight: 2}]->(u9),
            (u4)-[:Edge {weight: 4}]->(u9);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
8|0|2|0
8|1|2|0
3|2|3|0
20|2|5|0
3|3|4|0
4|4|9|0
20|5|6|0
10|5|7|0
3|8|9|0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='min')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
5|0|1|0
6|0|2|0
3|2|3|0
3|3|4|0
2|4|9|0
10|5|7|0
3|6|7|0
10|7|8|0
3|8|9|0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='max')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 9
8|0|2|3
8|1|2|3
20|2|5|3
3|3|4|3
4|4|9|3
20|5|6|3
10|5|7|3
10|7|8|3
3|8|9|3


-CASE InvalidWeightProperty
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight STRING);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- error
Runtime exception: Provided weight property is not numerical: weight


-CASE PropertyDoesNotExist
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight STRING);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='height')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- error
Runtime exception: Cannot find property: height


-CASE MultipleNodeTables
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE NODE TABLE Node2(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight STRING);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node', 'Node2'], ['Edge']);
---- ok
-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='height')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- error
Binder exception: SPANNING_FOREST only supports operations on one node table.


-CASE MultipleRelTables
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight STRING);
---- ok
-STATEMENT CREATE REL TABLE Edge2(FROM Node to Node, weight STRING);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge', 'Edge2']);
---- ok
-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='height')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- error
Binder exception: SPANNING_FOREST only supports operations on one rel table.


-CASE BadVariant
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight STRING);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok
-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='height', variant:='medium')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- error
Binder exception: Variant argument expects max or min. Got: medium


-CASE SingleNode
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0});
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 0


-CASE TwoNodeConnected
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u0)-[:Edge {weight: 5}]->(u1);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 1
5|0|1|0


-CASE LinearChain
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u0)-[:Edge {weight: 1}]->(u1),
            (u1)-[:Edge {weight: 2}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 4}]->(u4);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 4
1|0|1|3
2|1|2|3
3|2|3|3
4|3|4|3


-CASE StarGraph
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u0)-[:Edge {weight: 1}]->(u1),
            (u0)-[:Edge {weight: 2}]->(u2),
            (u0)-[:Edge {weight: 3}]->(u3),
            (u0)-[:Edge {weight: 4}]->(u4);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 4
1|0|1|0
2|0|2|0
3|0|3|0
4|0|4|0


-CASE CompleteGraph
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u0)-[:Edge {weight: 1}]->(u1),
            (u0)-[:Edge {weight: 2}]->(u2),
            (u0)-[:Edge {weight: 3}]->(u3),
            (u1)-[:Edge {weight: 4}]->(u2),
            (u1)-[:Edge {weight: 5}]->(u3),
            (u2)-[:Edge {weight: 6}]->(u3);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 3
1|0|1|2
2|0|2|2
3|0|3|2


-CASE TreeStructure
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u0)-[:Edge {weight: 10}]->(u1),
            (u0)-[:Edge {weight: 15}]->(u2),
            (u1)-[:Edge {weight: 20}]->(u3),
            (u1)-[:Edge {weight: 25}]->(u4),
            (u2)-[:Edge {weight: 30}]->(u5),
            (u2)-[:Edge {weight: 35}]->(u6);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 6
10|0|1|3
15|0|2|3
20|1|3|3
25|1|4|3
30|2|5|3
35|2|6|3


-CASE UnbalancedComponents
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u4:Node {id: 4}),
            (u5:Node {id: 5}),
            (u6:Node {id: 6}),
            (u7:Node {id: 7}),
            (u8:Node {id: 8}),
            (u9:Node {id: 9}),
            (u0)-[:Edge {weight: 1}]->(u1),
            (u1)-[:Edge {weight: 2}]->(u2),
            (u2)-[:Edge {weight: 3}]->(u3),
            (u3)-[:Edge {weight: 4}]->(u4),
            (u4)-[:Edge {weight: 5}]->(u5),
            (u5)-[:Edge {weight: 6}]->(u6),
            (u7)-[:Edge {weight: 10}]->(u8);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 7
1|0|1|6
2|1|2|6
3|2|3|6
4|3|4|6
5|4|5|6
6|5|6|6
10|7|8|8


-CASE TieBreaking
-LOAD_DYNAMIC_EXTENSION algo
-STATEMENT CREATE NODE TABLE Node(id INT64 PRIMARY KEY);
---- ok
-STATEMENT CREATE REL TABLE Edge(FROM Node to Node, weight INT64);
---- ok
-STATEMENT CREATE (u0:Node {id: 0}),
            (u1:Node {id: 1}),
            (u2:Node {id: 2}),
            (u3:Node {id: 3}),
            (u0)-[:Edge {weight: 1}]->(u1),
            (u0)-[:Edge {weight: 1}]->(u2),
            (u1)-[:Edge {weight: 1}]->(u3),
            (u2)-[:Edge {weight: 1}]->(u3);
---- ok
-STATEMENT CALL PROJECT_GRAPH('Graph', ['Node'], ['Edge']);
---- ok

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 3
1|1|3|0
1|0|2|0
1|2|3|0

-STATEMENT CALL SPANNING_FOREST('Graph', weight_property:='weight', variant:='max')
    RETURN rel.weight as weight, src.id AS src, dst.id AS dst, forest_id
    ORDER BY forest_id;
---- 3
1|0|1|2
1|0|2|2
1|1|3|2
