load from '../movies.json';
load from '../movies.json' return *;
load extension json;
load from '../movies.json' return *;
reate node table person (ID INt64, fName StRING, gender INT64, isStudent BoOLEAN, isWorker BOOLEAN, age INT64, eyeSight DOUBLE, birthdate DATE, registerTime TIMESTAMP, lastJobDuration interval, workedHours INT64[], usedNames STRING[], courseScoresPerTerm INT64[][], grades INT64[4], height float, u UUID, PRIMARY KEY (ID));
create node table organisation (ID INT64, name STRING, orgCode INT64, mark DOUBLE, score INT64, history STRING, licenseValidInterval INTERVAL, rating DOUBLE, state STRUCT(revenue INT16, location STRING[], stock STRUCT(price INT64[], volume INT64)), info UNION(price FLOAT, movein DATE, note STRING),PRIMARY KEY (ID));
create node table movies (name STRING, length INT32, note STRING, description STRUCT(rating DOUBLE, stars INT8, views INT64, release TIMESTAMP, release_ns TIMESTAMP_NS, release_ms TIMESTAMP_MS, release_sec TIMESTAMP_SEC, release_tz TIMESTAMP_TZ, film DATE, u8 UINT8, u16 UINT16, u32 UINT32, u64 UINT64, hugedata INT128), content BYTEA, audience MAP(STRING, INT64), grade union(credit boolean, grade1 double, grade2 int64), PRIMARY KEY (name));
create rel table knows (FROM person TO person, date DATE, meetTime TIMESTAMP, validInterval INTERVAL, comments STRING[], summary STRUCT(locations STRING[], transfer STRUCT(day DATE, amount INT64[])), notes UNION(firstmet DATE, type INT16, comment STRING), someMap MAP(STRING, STRING), MANY_MAnY);
create rel table studyAt (FROM person TO organisation, year INT64, places STRING[], length INT16, level INT8, code UINT64, temperature UINT32, ulength UINT16, ulevel UINT8, hugedata INT128, MANY_ONe);
create rel table workAt (FROM person TO organisation, year INT64, grading DOUBLE[2], rating float, MANY_ONE);
create rel table meets (FROM person TO person, location FLOAT[2], times INT, data BYTEA, MANY_ONE);
create rel table marries (FROM person TO person, usedAddress STRING[], address INT16[2], note STRING, ONE_ONE);
create node table person (ID INt64, fName StRING, gender INT64, isStudent BoOLEAN, isWorker BOOLEAN, age INT64, eyeSight DOUBLE, birthdate DATE, registerTime TIMESTAMP, lastJobDuration interval, workedHours INT64[], usedNames STRING[], courseScoresPerTerm INT64[][], grades INT64[4], height float, u UUID, PRIMARY KEY (ID));
create node table organisation (ID INT64, name STRING, orgCode INT64, mark DOUBLE, score INT64, history STRING, licenseValidInterval INTERVAL, rating DOUBLE, state STRUCT(revenue INT16, location STRING[], stock STRUCT(price INT64[], volume INT64)), info UNION(price FLOAT, movein DATE, note STRING),PRIMARY KEY (ID));
create node table movies (name STRING, length INT32, note STRING, description STRUCT(rating DOUBLE, stars INT8, views INT64, release TIMESTAMP, release_ns TIMESTAMP_NS, release_ms TIMESTAMP_MS, release_sec TIMESTAMP_SEC, release_tz TIMESTAMP_TZ, film DATE, u8 UINT8, u16 UINT16, u32 UINT32, u64 UINT64, hugedata INT128), content BYTEA, audience MAP(STRING, INT64), grade union(credit boolean, grade1 double, grade2 int64), PRIMARY KEY (name));
create rel table knows (FROM person TO person, date DATE, meetTime TIMESTAMP, validInterval INTERVAL, comments STRING[], summary STRUCT(locations STRING[], transfer STRUCT(day DATE, amount INT64[])), notes UNION(firstmet DATE, type INT16, comment STRING), someMap MAP(STRING, STRING), MANY_MAnY);
create rel table studyAt (FROM person TO organisation, year INT64, places STRING[], length INT16, level INT8, code UINT64, temperature UINT32, ulength UINT16, ulevel UINT8, hugedata INT128, MANY_ONe);
create rel table workAt (FROM person TO organisation, year INT64, grading DOUBLE[2], rating float, MANY_ONE);
create rel table meets (FROM person TO person, location FLOAT[2], times INT, data BYTEA, MANY_ONE);
create rel table marries (FROM person TO person, usedAddress STRING[], address INT16[2], note STRING, ONE_ONE);
load extension "extension/json/build/libjson.kuzu_extension";
copy person from "dataset/tinysnb_json/vPerson.json";
copy person from "dataset/tinysnb_json/vPerson2.json";
copy organisation from "dataset/tinysnb_json/vOrganisation.json";
copy movies from "dataset/tinysnb_json/vMovies.json";
copy knows from "dataset/tinysnb_json/eKnows.json";
copy knows from "dataset/tinysnb_json/eKnows_2.json";
copy studyAt from "dataset/tinysnb_json/eStudyAt.json";
copy workAt from "dataset/tinysnb_json/eWorkAt.json";
copy meets from "dataset/tinysnb_json/eMeets.json";
copy marries from "dataset/tinysnb_json/eMarries.json";
COPY (MATCH (m:movies) RETURN m.*) TO "../movies.json";
load from '../movies.json' return *;
load extension json;
load from 'dataset/tinysnb_json/vMovies.json';
load from 'dataset/tinysnb_json/vMovies.json' return *;
load from '../test.json' return *: ;
load from '../test.json' return *;
load extension json;
load from '../test.json' return *;
load extension json;
load from '../test.json' return *;
load extension json;
load from '../test.json' return *;
load extension json;
load from '../test.json' return *;
load from '../movies.json' return *;
load extension json;
load extension json ;
load from '../movies.json' return *;
load from '../test.json' return *;
create node table person (ID INt64, fName StRING, gender INT64, isStudent BoOLEAN, isWorker BOOLEAN, age INT64, eyeSight DOUBLE, birthdate DATE, registerTime TIMESTAMP, lastJobDuration interval, workedHours INT64[], usedNames STRING[], courseScoresPerTerm INT64[][], grades INT64[4], height float, u UUID, PRIMARY KEY (ID));
create node table organisation (ID INT64, name STRING, orgCode INT64, mark DOUBLE, score INT64, history STRING, licenseValidInterval INTERVAL, rating DOUBLE, state STRUCT(revenue INT16, location STRING[], stock STRUCT(price INT64[], volume INT64)), info UNION(price FLOAT, movein DATE, note STRING),PRIMARY KEY (ID));
create node table movies (name STRING, length INT32, note STRING, description STRUCT(rating DOUBLE, stars INT8, views INT64, release TIMESTAMP, release_ns TIMESTAMP_NS, release_ms TIMESTAMP_MS, release_sec TIMESTAMP_SEC, release_tz TIMESTAMP_TZ, film DATE, u8 UINT8, u16 UINT16, u32 UINT32, u64 UINT64, hugedata INT128), content BYTEA, audience MAP(STRING, INT64), grade union(credit boolean, grade1 double, grade2 int64), PRIMARY KEY (name));
create rel table knows (FROM person TO person, date DATE, meetTime TIMESTAMP, validInterval INTERVAL, comments STRING[], summary STRUCT(locations STRING[], transfer STRUCT(day DATE, amount INT64[])), notes UNION(firstmet DATE, type INT16, comment STRING), someMap MAP(STRING, STRING), MANY_MAnY);
create rel table studyAt (FROM person TO organisation, year INT64, places STRING[], length INT16, level INT8, code UINT64, temperature UINT32, ulength UINT16, ulevel UINT8, hugedata INT128, MANY_ONe);
create rel table workAt (FROM person TO organisation, year INT64, grading DOUBLE[2], rating float, MANY_ONE);
create rel table meets (FROM person TO person, location FLOAT[2], times INT, data BYTEA, MANY_ONE);
create rel table marries (FROM person TO person, usedAddress STRING[], address INT16[2], note STRING, ONE_ONE);
load extension "extension/json/build/libjson.kuzu_extension";
copy person from "dataset/tinysnb_json/vPerson.json";
copy person from "dataset/tinysnb_json/vPerson2.json";
copy organisation from "dataset/tinysnb_json/vOrganisation.json";
copy movies from "dataset/tinysnb_json/vMovies.json";
load extension json;
load extension "extension/json/build/libjson.kuzu_extension";
return cast({a: 1, b: 2} as struct(a int32, b int32, c int32));
return [] + ['a'];
create node table person (ID INt64, fName StRING, gender INT64, isStudent BoOLEAN, isWorker BOOLEAN, age INT64, eyeSight DOUBLE, birthdate DATE, registerTime TIMESTAMP, lastJobDuration interval, workedHours INT64[], usedNames STRING[], courseScoresPerTerm INT64[][], grades INT64[4], height float, u UUID, PRIMARY KEY (ID));
create node table organisation (ID INT64, name STRING, orgCode INT64, mark DOUBLE, score INT64, history STRING, licenseValidInterval INTERVAL, rating DOUBLE, state STRUCT(revenue INT16, location STRING[], stock STRUCT(price INT64[], volume INT64)), info UNION(price FLOAT, movein DATE, note STRING),PRIMARY KEY (ID));
create node table movies (name STRING, length INT32, note STRING, description STRUCT(rating DOUBLE, stars INT8, views INT64, release TIMESTAMP, release_ns TIMESTAMP_NS, release_ms TIMESTAMP_MS, release_sec TIMESTAMP_SEC, release_tz TIMESTAMP_TZ, film DATE, u8 UINT8, u16 UINT16, u32 UINT32, u64 UINT64, hugedata INT128), content BYTEA, audience MAP(STRING, INT64), grade union(credit boolean, grade1 double, grade2 int64), PRIMARY KEY (name));
create rel table knows (FROM person TO person, date DATE, meetTime TIMESTAMP, validInterval INTERVAL, comments STRING[], summary STRUCT(locations STRING[], transfer STRUCT(day DATE, amount INT64[])), notes UNION(firstmet DATE, type INT16, comment STRING), someMap MAP(STRING, STRING), MANY_MAnY);
create rel table studyAt (FROM person TO organisation, year INT64, places STRING[], length INT16, level INT8, code UINT64, temperature UINT32, ulength UINT16, ulevel UINT8, hugedata INT128, MANY_ONe);
create rel table workAt (FROM person TO organisation, year INT64, grading DOUBLE[2], rating float, MANY_ONE);
create rel table meets (FROM person TO person, location FLOAT[2], times INT, data BYTEA, MANY_ONE);
create rel table marries (FROM person TO person, usedAddress STRING[], address INT16[2], note STRING, ONE_ONE);
load extension "extension/json/build/libjson.kuzu_extension";
copy person from "dataset/tinysnb_json/vPerson.json";
copy person from "dataset/tinysnb_json/vPerson2.json";
copy organisation from "dataset/tinysnb_json/vOrganisation.json";
copy movies from "dataset/tinysnb_json/vMovies.json";
copy knows from "dataset/tinysnb_json/eKnows.json";
copy knows from "dataset/tinysnb_json/eKnows_2.json";
copy studyAt from "dataset/tinysnb_json/eStudyAt.json";
copy workAt from "dataset/tinysnb_json/eWorkAt.json";
copy meets from "dataset/tinysnb_json/eMeets.json";
copy marries from "dataset/tinysnb_json/eMarries.json";
load extension json;
copy person from "dataset/tinysnb_json/vPerson.json";
d 1 ;
run ;
load extension json;
copy person from "dataset/tinysnb_json/vPerson.json";
load extension json;
copy person from "dataset/tinysnb_json/vPerson.json";
match (p:person) delete detach p;
match (p:person) detach delete p;
copy person from "dataset/tinysnb_json/vPerson.json";
create node table person (ID INt64, fName StRING, gender INT64, isStudent BoOLEAN, isWorker BOOLEAN, age INT64, eyeSight DOUBLE, birthdate DATE, registerTime TIMESTAMP, lastJobDuration interval, workedHours INT64[], usedNames STRING[], courseScoresPerTerm INT64[][], grades INT64[4], height float, u UUID, PRIMARY KEY (ID));
create node table organisation (ID INT64, name STRING, orgCode INT64, mark DOUBLE, score INT64, history STRING, licenseValidInterval INTERVAL, rating DOUBLE, state STRUCT(revenue INT16, location STRING[], stock STRUCT(price INT64[], volume INT64)), info UNION(price FLOAT, movein DATE, note STRING),PRIMARY KEY (ID));
create node table movies (name STRING, length INT32, note STRING, description STRUCT(rating DOUBLE, stars INT8, views INT64, release TIMESTAMP, release_ns TIMESTAMP_NS, release_ms TIMESTAMP_MS, release_sec TIMESTAMP_SEC, release_tz TIMESTAMP_TZ, film DATE, u8 UINT8, u16 UINT16, u32 UINT32, u64 UINT64, hugedata INT128), content BYTEA, audience MAP(STRING, INT64), grade union(credit boolean, grade1 double, grade2 int64), PRIMARY KEY (name));
create rel table knows (FROM person TO person, date DATE, meetTime TIMESTAMP, validInterval INTERVAL, comments STRING[], summary STRUCT(locations STRING[], transfer STRUCT(day DATE, amount INT64[])), notes UNION(firstmet DATE, type INT16, comment STRING), someMap MAP(STRING, STRING), MANY_MAnY);
create rel table studyAt (FROM person TO organisation, year INT64, places STRING[], length INT16, level INT8, code UINT64, temperature UINT32, ulength UINT16, ulevel UINT8, hugedata INT128, MANY_ONe);
create rel table workAt (FROM person TO organisation, year INT64, grading DOUBLE[2], rating float, MANY_ONE);
create rel table meets (FROM person TO person, location FLOAT[2], times INT, data BYTEA, MANY_ONE);
create rel table marries (FROM person TO person, usedAddress STRING[], address INT16[2], note STRING, ONE_ONE);
load extension "extension/json/build/libjson.kuzu_extension";
copy person from "dataset/tinysnb_json/vPerson.json";
copy person from "dataset/tinysnb_json/vPerson2.json";
copy organisation from "dataset/tinysnb_json/vOrganisation.json";
copy movies from "dataset/tinysnb_json/vMovies.json";
copy knows from "dataset/tinysnb_json/eKnows.json";
copy knows from "dataset/tinysnb_json/eKnows_2.json";
copy studyAt from "dataset/tinysnb_json/eStudyAt.json";
copy workAt from "dataset/tinysnb_json/eWorkAt.json";
copy meets from "dataset/tinysnb_json/eMeets.json";
copy marries from "dataset/tinysnb_json/eMarries.json";
match (m:movies) return m.*;
match (m:movies) detach delete m;
copy movies from "dataset/tinysnb_json/vMovies.json";
load extension json;
copy movies from "dataset/tinysnb_json/vMovies.json";
match (m:movies) return m.grade;
load extension 'extension/json/build/libjson.kuzu_extension';
match (m:movies) detach delete m;
copy movies from "dataset/tinysnb_json/vMovies.json";
match (m:movies) return m.grade;
match (m:movies) delete m;
load extension json;
copy movies from 'dataset/tinysnb_json/vMovies.json';
match (m:movies) return m.*;
load extension json; match (m:movies) delete m; copy movies from "dataset/tinysnb_json/vMovies.json";
match (m:movies) return m.grades;
match (m:movies) return m.grade;
load extension json; match (m:movies) delete m; copy movies from "dataset/tinysnb_json/vMovies.json";
match (m:movies) return m.grade;
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return *;
load extension json;
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return *;
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return json_extract(*, 'name');
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return json_extract(json, 'name');
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return json_extract(json, 'length');
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return json_schema(json);
load extension json;
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return json_schema(json);
load extension json;
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return json_schema(json);
load extension json;
load from 'dataset/tinysnb_json/vMovies.json'(maximum_depth=1, sample_size=3) return json_structure(json);
