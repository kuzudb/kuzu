#pragma once

#include "processor/operator/physical_operator.h"
#include "storage/copier/read_file_state.h"

namespace kuzu {
namespace processor {

class ReadFile : public PhysicalOperator {
public:
    ReadFile(const DataPos& rowIdxVectorPos, const DataPos& filePathVectorPos,
        std::vector<DataPos> dataColumnPoses,
        std::shared_ptr<storage::ReadFileSharedState> sharedState,
        PhysicalOperatorType operatorType, uint32_t id, const std::string& paramsString)
        : PhysicalOperator{operatorType, id, paramsString}, rowIdxVectorPos{rowIdxVectorPos},
          filePathVectorPos{filePathVectorPos}, dataColumnPoses{std::move(dataColumnPoses)},
          sharedState{std::move(sharedState)}, rowIdxVector{nullptr}, filePathVector{nullptr} {}

    void initLocalStateInternal(ResultSet* resultSet, ExecutionContext* context) override;

    inline void initGlobalStateInternal(kuzu::processor::ExecutionContext* context) override {
        sharedState->countNumRows();
    }

    inline bool isSource() const override { return true; }

protected:
    virtual std::shared_ptr<arrow::RecordBatch> readTuples(
        std::unique_ptr<storage::ReadFileMorsel> morsel) = 0;

    bool getNextTuplesInternal(ExecutionContext* context) override;

protected:
    std::shared_ptr<storage::ReadFileSharedState> sharedState;
    DataPos rowIdxVectorPos;
    DataPos filePathVectorPos;
    std::vector<DataPos> dataColumnPoses;
    common::ValueVector* rowIdxVector;
    common::ValueVector* filePathVector;
    std::vector<common::ValueVector*> dataColumnVectors;
};

} // namespace processor
} // namespace kuzu
